# TablEZ writeup - 100 point RE challenge

The challenge description:

![image](https://user-images.githubusercontent.com/41026969/56436169-f1119580-62a8-11e9-9355-3be5ce621652.png)

### Starting off

So from the challenge description it looks like we'll be dealing with some sort of table. From the last sentence is sounds like there'll be some tables that'll translate our input to make it encoded...

Downloading the binary and doing a ```./file``` check shows that it is a 64 bit linux file:

![image](https://user-images.githubusercontent.com/41026969/56436319-63827580-62a9-11e9-8e01-8f39672516bd.png)

Running the executable/playing around with it, this is what it outputs:

![image](https://user-images.githubusercontent.com/41026969/56436380-a2b0c680-62a9-11e9-8157-e853882e5869.png)

So at a first glance, we see that the program prompts us to enter a flag, and then checks it.

### Reverse engineering with IDA pro

Popping the progrma into IDA Pro 64 this is the main function:

![image](https://user-images.githubusercontent.com/41026969/56436646-92e5b200-62aa-11e9-90fb-31e06431c2d6.png)

We see some interesting hex variables being initialized and stored... we then see when the program prompts us to ```Please enter the flag"``` and when it calls ```fgets()```.

Scrolling down a bit futher, we see some more stuff happening. Here's the graph view:

![image](https://user-images.githubusercontent.com/41026969/56452868-9fe3bf00-6305-11e9-9a09-bae9b72fd55c.png)

Here's the pseudocode that IDA creates:

![image](https://user-images.githubusercontent.com/41026969/56452885-e1746a00-6305-11e9-853f-31d76e79602f.png)

So from the above, we can see that for every char that we inputted it gets replaced from whatever ```get_tbl_entry``` returns. Then after all the chars we inputted gets replaced from the ```get_tbl_entry``` function, the program first checks if the resulting string has a length of 37, if so, it string compares with ```s2```.

##### note: ```s2``` is seen in hex form on the graph view of ida. It's those interesting hex variables being intialized in the first picture

##### also note: since we are dealing with x86-64 bit (as seen from the ```file``` check) we are dealing with little endian. This means those hex values mentioned above, are stored backwards. 

IDA has a cool feature that you can do that will display the hex values in order, so that it is easier to read, just highlight the hex string, right click, and one of the options shows the hex string backwards, click the one. Here it is shown below:

![image](https://user-images.githubusercontent.com/41026969/56453251-b68e1400-630d-11e9-8646-f000eed5d87a.png)

Doing the above, we see the hex version of ```s2``` which is what it's comparing our input by.

Let's check out the ```get_tbl_entry``` function:

![image](https://user-images.githubusercontent.com/41026969/56453284-2b614e00-630e-11e9-8900-2a091353215d.png)

So this function takes in a char and returns a char. It takes the char passed in, looks it up in ```trans_tbl``` (using a for loop, with ```i``` incrementing) and when found, returns the char found at the array ```byte_201281``` at index ```[2 * i]``` (i being the variable that's incrementing the for loop). Notice how the ```i``` variable goes through the array by two (it doesn't go to index i, it goes to index 2 * i).

Let's check out those two arrays:

![image](https://user-images.githubusercontent.com/41026969/56454228-864d7200-631b-11e9-9028-e1bc666fb886.png)

So from the image above, we can see that ```trans_tabl``` starts at 1, then has the same contents as ```byte_201281```. So basically ```trans_tabl``` is ```byte_201281``` with every index shifted up one. 

### The solution
So that now we know how to program works, the table contents, and the string that it's comparing it by, we can reverse engineer the process to get the flag.

I decided to write a python program to do this for me. The program needs to do the reverse of what's in the pseudocode. This is what it should contain:

1) Have a loop for every character in the hex string 
2) For each character, find the index in which it appears in ```byte_201281```. 
3) Using that^ index number, look it up in the ```trans_tabl```.
4) get the flag

Here's the python program I wrote (also available for download at the top):

```python
"""
This python program will get what we're supposed to input, and output what the flag is

The actual program will look for a value in trans_tbl and return the corresponding byte_201281 value

This program (designed to do the reverse) will take the value that we're expecting, look it up in 
the byte_201281 array, and return the corresponding trans_tbl value
"""

# this variable will hold the flag
flag = "" 

# simulating the trans_tbl array
trans_tbl = "\x01\xBB\x02\x9B\x03\xC4\x04\x6C\x05\x4A\x06\x2E\x07\x22\x08\x45\x09\x33\x0A\xB8\x0B\xD5\x0C\x06\x0D\x0A\x0E\xBC\x0F\xFA\x10\x79\x11\x24\x12\xE1\x13\xB2\x14\xBF\x15\x2C\x16\xAD\x17\x86\x18\x60\x19\xA4\x1A\xB6\x1B\xD8\x1C\x59\x1D\x87\x1E\x41\x1F\x94\x20\x77\x21\xF0\x22\x4F\x23\xCB\x24\x61\x25\x25\x26\xC0\x27\x97\x28\x2A\x29\x5C\x2A\x08\x2B\xC9\x2C\x9F\x2D\x43\x2E\x4E\x2F\xCF\x30\xF9\x31\x3E\x32\x6F\x33\x65\x34\xE7\x35\xC5\x36\x39\x37\xB7\x38\xEF\x39\xD0\x3A\xC8\x3B\x2F\x3C\xAA\x3D\xC7\x3E\x47\x3F\x3C\x40\x81\x41\x32\x42\x49\x43\xD3\x44\xA6\x45\x96\x46\x2B\x47\x58\x48\x40\x49\xF1\x4A\x9C\x4B\xEE\x4C\x1A\x4D\x5B\x4E\xC6\x4F\xD6\x50\x80\x51\x2D\x52\x6D\x53\x9A\x54\x3D\x55\xA7\x56\x93\x57\x84\x58\xE0\x59\x12\x5A\x3B\x5B\xB9\x5C\x09\x5D\x69\x5E\xBA\x5F\x99\x60\x48\x61\x73\x62\xB1\x63\x7C\x64\x82\x65\xBE\x66\x27\x67\x9D\x68\xFB\x69\x67\x6A\x7E\x6B\xF4\x6C\xB3\x6D\x05\x6E\xC2\x6F\x5F\x70\x1B\x71\x54\x72\x23\x73\x71\x74\x11\x75\x30\x76\xD2\x77\xA5\x78\x68\x79\x9E\x7A\x3F\x7B\xF5\x7C\x7A\x7D\xCE\x7E\x0B\x7F\x0C\x80\x85\x81\xDE\x82\x63\x83\x5E\x84\x8E\x85\xBD\x86\xFE\x87\x6A\x88\xDA\x89\x26\x8A\x88\x8B\xE8\x8C\xAC\x8D\x03\x8E\x62\x8F\xA8\x90\xF6\x91\xF7\x92\x75\x93\x6B\x94\xC3\x95\x46\x96\x51\x97\xE6\x98\x8F\x99\x28\x9A\x76\x9B\x5A\x9C\x91\x9D\xEC\x9E\x1F\x9F\x44\xA0\x52\xA1\x01\xA2\xFC\xA3\x8B\xA4\x3A\xA5\xA1\xA6\xA3\xA7\x16\xA8\x10\xA9\x14\xAA\x50\xAB\xCA\xAC\x95\xAD\x92\xAE\x4B\xAF\x35\xB0\x0E\xB1\xB5\xB2\x20\xB3\x1D\xB4\x5D\xB5\xC1\xB6\xE2\xB7\x6E\xB8\x0F\xB9\xED\xBA\x90\xBB\xD4\xBC\xD9\xBD\x42\xBE\xDD\xBF\x98\xC0\x57\xC1\x37\xC2\x19\xC3\x78\xC4\x56\xC5\xAF\xC6\x74\xC7\xD1\xC8\x04\xC9\x29\xCA\x55\xCB\xE5\xCC\x4C\xCD\xA0\xCE\xF2\xCF\x89\xD0\xDB\xD1\xE4\xD2\x38\xD3\x83\xD4\xEA\xD5\x17\xD6\x07\xD7\xDC\xD8\x8C\xD9\x8A\xDA\xB4\xDB\x7B\xDC\xE9\xDD\xFF\xDE\xEB\xDF\x15\xE0\x0D\xE1\x02\xE2\xA2\xE3\xF3\xE4\x34\xE5\xCC\xE6\x18\xE7\xF8\xE8\x13\xE9\x8D\xEA\x7F\xEB\xAE\xEC\x21\xED\xE3\xEE\xCD\xEF\x4D\xF0\x70\xF1\x53\xF2\xFD\xF3\xAB\xF4\x72\xF5\x64\xF6\x1C\xF7\x66\xF8\xA9\xF9\xB0\xFA\x1E\xFB\xD7\xFC\xDF\xFD\x36\xFE\x7D\xFF\x31"

# simulating the byte_201281 array
byte_array = "\xBB\x02\x9B\x03\xC4\x04\x6C\x05\x4A\x06\x2E\x07\x22\x08\x45\x09\x33\x0A\xB8\x0B\xD5\x0C\x06\x0D\x0A\x0E\xBC\x0F\xFA\x10\x79\x11\x24\x12\xE1\x13\xB2\x14\xBF\x15\x2C\x16\xAD\x17\x86\x18\x60\x19\xA4\x1A\xB6\x1B\xD8\x1C\x59\x1D\x87\x1E\x41\x1F\x94\x20\x77\x21\xF0\x22\x4F\x23\xCB\x24\x61\x25\x25\x26\xC0\x27\x97\x28\x2A\x29\x5C\x2A\x08\x2B\xC9\x2C\x9F\x2D\x43\x2E\x4E\x2F\xCF\x30\xF9\x31\x3E\x32\x6F\x33\x65\x34\xE7\x35\xC5\x36\x39\x37\xB7\x38\xEF\x39\xD0\x3A\xC8\x3B\x2F\x3C\xAA\x3D\xC7\x3E\x47\x3F\x3C\x40\x81\x41\x32\x42\x49\x43\xD3\x44\xA6\x45\x96\x46\x2B\x47\x58\x48\x40\x49\xF1\x4A\x9C\x4B\xEE\x4C\x1A\x4D\x5B\x4E\xC6\x4F\xD6\x50\x80\x51\x2D\x52\x6D\x53\x9A\x54\x3D\x55\xA7\x56\x93\x57\x84\x58\xE0\x59\x12\x5A\x3B\x5B\xB9\x5C\x09\x5D\x69\x5E\xBA\x5F\x99\x60\x48\x61\x73\x62\xB1\x63\x7C\x64\x82\x65\xBE\x66\x27\x67\x9D\x68\xFB\x69\x67\x6A\x7E\x6B\xF4\x6C\xB3\x6D\x05\x6E\xC2\x6F\x5F\x70\x1B\x71\x54\x72\x23\x73\x71\x74\x11\x75\x30\x76\xD2\x77\xA5\x78\x68\x79\x9E\x7A\x3F\x7B\xF5\x7C\x7A\x7D\xCE\x7E\x0B\x7F\x0C\x80\x85\x81\xDE\x82\x63\x83\x5E\x84\x8E\x85\xBD\x86\xFE\x87\x6A\x88\xDA\x89\x26\x8A\x88\x8B\xE8\x8C\xAC\x8D\x03\x8E\x62\x8F\xA8\x90\xF6\x91\xF7\x92\x75\x93\x6B\x94\xC3\x95\x46\x96\x51\x97\xE6\x98\x8F\x99\x28\x9A\x76\x9B\x5A\x9C\x91\x9D\xEC\x9E\x1F\x9F\x44\xA0\x52\xA1\x01\xA2\xFC\xA3\x8B\xA4\x3A\xA5\xA1\xA6\xA3\xA7\x16\xA8\x10\xA9\x14\xAA\x50\xAB\xCA\xAC\x95\xAD\x92\xAE\x4B\xAF\x35\xB0\x0E\xB1\xB5\xB2\x20\xB3\x1D\xB4\x5D\xB5\xC1\xB6\xE2\xB7\x6E\xB8\x0F\xB9\xED\xBA\x90\xBB\xD4\xBC\xD9\xBD\x42\xBE\xDD\xBF\x98\xC0\x57\xC1\x37\xC2\x19\xC3\x78\xC4\x56\xC5\xAF\xC6\x74\xC7\xD1\xC8\x04\xC9\x29\xCA\x55\xCB\xE5\xCC\x4C\xCD\xA0\xCE\xF2\xCF\x89\xD0\xDB\xD1\xE4\xD2\x38\xD3\x83\xD4\xEA\xD5\x17\xD6\x07\xD7\xDC\xD8\x8C\xD9\x8A\xDA\xB4\xDB\x7B\xDC\xE9\xDD\xFF\xDE\xEB\xDF\x15\xE0\x0D\xE1\x02\xE2\xA2\xE3\xF3\xE4\x34\xE5\xCC\xE6\x18\xE7\xF8\xE8\x13\xE9\x8D\xEA\x7F\xEB\xAE\xEC\x21\xED\xE3\xEE\xCD\xEF\x4D\xF0\x70\xF1\x53\xF2\xFD\xF3\xAB\xF4\x72\xF5\x64\xF6\x1C\xF7\x66\xF8\xA9\xF9\xB0\xFA\x1E\xFB\xD7\xFC\xDF\xFD\x36\xFE\x7D\xFF\x31"

# hex values saw initialized in main function (in IDA pro)
compared_flag = "\x27\xB3\x73\x9D\xF5\x11\xE7\xB1\xB3\xBE\x99\xB3\xF9\xF9\xF4\x30\x1B\x71\x99\x73\x23\x65\x99\xB1\x65\x11\x11\xBE\x23\x99\x27\xF9\x23\x99\x05\x65\xCE"

# magic work done here
for i in compared_flag: # for each character in the compared_flag variable
	for j in range(0, 509, 2): # for loop, goes from 0 to 509, increments by 2
		if byte_array[j] == i: # looks it up in the byte array
			flag += trans_tbl[j] # gets the corresponding trans_tbl value 
			break

# Already converted from hex to string for us!
print flag
```

Running the program yields us the flag!!

```flag{t4ble_l00kups_ar3_b3tter_f0r_m3}```
